let allPets;
let numberOfCards = 0;

start();
async function start() {
  try {
    const res = await fetch('./assets/data.json');
    allPets = await res.json();
  } catch (err) {
    console.log(err.message);
  }
  // console.log(allPets);
  generateAllCards();
}

const petsCardsContainer = document.querySelector(
  '.our-friends-list.pagination'
);

function generateAllCards() {
  let allCards = [];
  countCardsPerPage();

  for (let i = 0; i < numberOfCards; i++) {
    let randomNumber = Math.floor(Math.random() * allPets.length);
    if (allCards.includes(randomNumber)) i--;
    else allCards.push(randomNumber);
  }

  //Split into three sub-arrays
  let size = 3;
  let arr = [];
  for (let i = 0; i < Math.ceil(allCards.length / size); i++) {
    arr[i] = allCards.slice(i * size, i * size + size);
  }

  // let arr = [
  //   [allCards[0], allCards[1], allCards[2]],
  //   [allCards[3], allCards[4], allCards[5]],
  //   [allCards[6], allCards[7]],
  // ];

  let result = [];

  for (let i = 0; i < 6; i++) {
    arr.forEach((item) => {
      result.push(shuffle(item));
    });
  }

  result = result.flat();
  console.log(result);

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      let j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
}

function countCardsPerPage() {
  const width = document.body.offsetWidth;

  numberOfCards = 6;
  if (width < 768) {
    numberOfCards = 3;
  } else if (width >= 1280) {
    numberOfCards = 8;
  }
}
// Иначе говоря, вначале мы можем сформировать абсолютно любой порадок из имеющихся элементов, но сделать так, чтобы между ЛЮБЫМИ двумя одинаковыми элементами было НЕ МЕНЬШЕ 5 других элементов. Иначе при пагинации на 6 карточек возможны "дубли"

// Данное действие можно реализавать 4 этапа:
// 1. генерация "зерна" - мы же хотим НАСТОЯЩИЙ рандом;
// 2. Нарезка данного "зерна" на составные части;
// 3. Последовательная модификация каждого отдельного "суб-зерна" для финальной сборки;
// 4. Финальная сборка.

// \\\\\\\\\\\\Генерация "зерна"\\\\\\\\\\\\
// Здесь нам абсолютно не важно в каком порядке сгенерировать последовательность, главное "зерно" должно быть одинаковым по длинне массиву петов и все значения внутри него должны быть уникальными.

// Для такой цели хорошо-бы написать пару функции: одна из которых генерировала бы уникальное значени в определённом диапозоне, а вторая пыталась бы заполнить "зерно" уникальными значениями до длинны петов.

// return > [3, 1, 6, 7, 5, 2, 4, 0]

// \\\\\\\\\\\\Нарезка "зерна"\\\\\\\\\\\\
// Вышеуказанных функций достаточно, чтобы корректно работала пагинация на 8 карточек, но на других значениях возможно будут дубли. Самое время немного "ограничить" наш рандом.
// Максимальное количество после 8 - это 6, следовательно нужно убедиться что между ЛЮБЫМИ идентичным значениями будет минимум 5 элементов.
// Для этого предлагаю нарезать данное зерно на три части:
// БЫЛО - [3, 1, 6, 7, 5, 2, 4, 0]
// СТАЛО - [3, 1, 6] [7, 5, 2] [4, 0]
// Теперь мы можем перемешивать значения внутри "суб-зерна" и при слиянии в один массив мы ГАРАНТИРОВАННО будем иметь отступ в пять элементов

// \\\\\\\\\\\\Модификация "суб-зерна"\\\\\\\\\\\\
// Всё просто - мы знаем длинну "суб-зерна" (3, либо 2), знаем возможное число комбинации (6 + 2) - думаю не надо объяснять что нужно делать.

// \\\\\\\\\\\\Финальная сборка.\\\\\\\\\\\\
// 1. Создайте пустой массив - [].
// 2. Положите последовательно ВСЕ модифицируемые "суб-зЁрна" в массив.
// 3. Повторите пункт 2 ещё пять раз.

// БЫЛО - [3, 1, 6] [7, 5, 2] [4, 0]
// СТАЛО - (48) [6, 3, 1, 7, 5, 2, 4, 0, 1, 3, 6, 5, 7, 2, 4, 0, 1, 6, 3, 5, 2, 7, 4, 0, 3, 6, 1, 7, 2, 5, 4, 0, 1, 3, 6, 5, 7, 2, 4, 0, 6, 3, 1, 7, 5, 2, 4, 0]

// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
// Генерация html
// \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
// Первый этап выполнен и у вас есть значения, на основе которых можно брать информацию из JSON файла и генерировать карточки

// Настоятельно рекомендую познакомиться с "insertAdjacentHTML" и попрактиковаться самостоятельно (пока дам маленькую подсказку):
// ///////////////////////
// const text-box = document.querySelector('.text-box');
// text-box.innerHTML = '';
// const helloA = `Hello Word`;
// const helloB = `Hello World`;
// const html = `
//       <div>
//           <p>${helloA}, ${helloB}!</p>
//       </div>
//     `;
// text-box.insertAdjacentHTML('afterbegin', html);
// ///////////////////////

// Касаемо кнопок - думаю, это слишком просто, чтобы объяснять:
// Всего четыре кнопки - всего  четыре простых логики.

// DimaD1988
